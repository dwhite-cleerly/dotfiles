set -g __fish_git_prompt_showdirtystate 'yes'
set -g __fish_git_prompt_char_dirtystate '±'
set -g __fish_git_prompt_char_cleanstate ''
set -q color_virtual_env_bg; or set color_virtual_env_bg white
set -q color_virtual_env_str; or set color_virtual_env_str black
set -q color_user_bg; or set color_user_bg black
set -q color_user_str; or set color_user_str yellow
set -q color_dir_bg; or set color_dir_bg blue
set -q color_dir_str; or set color_dir_str black
set -q color_hg_changed_bg; or set color_hg_changed_bg yellow
set -q color_hg_changed_str; or set color_hg_changed_str black
set -q color_hg_bg; or set color_hg_bg green
set -q color_hg_str; or set color_hg_str black
set -q color_git_dirty_bg; or set color_git_dirty_bg yellow
set -q color_git_dirty_str; or set color_git_dirty_str black
set -q color_git_bg; or set color_git_bg green
set -q color_git_str; or set color_git_str black
set -q color_svn_bg; or set color_svn_bg green
set -q color_svn_str; or set color_svn_str black
set -q color_status_nonzero_bg; or set color_status_nonzero_bg black
set -q color_status_nonzero_str; or set color_status_nonzero_str red
set -q color_status_superuser_bg; or set color_status_superuser_bg black
set -q color_status_superuser_str; or set color_status_superuser_str yellow
set -q color_status_jobs_bg; or set color_status_jobs_bg black
set -q color_status_jobs_str; or set color_status_jobs_str cyan

function parse_git_dirty
  if [ $__fish_git_prompt_showdirtystate = "yes" ]
    set -l submodule_syntax
    set submodule_syntax "--ignore-submodules=dirty"
    set untracked_syntax "--untracked-files=$fish_git_prompt_untracked_files"
    set git_dirty (command git status --porcelain $submodule_syntax $untracked_syntax 2> /dev/null)
    if [ -n "$git_dirty" ]
        echo -n "$__fish_git_prompt_char_dirtystate"
    else
        echo -n "$__fish_git_prompt_char_cleanstate"
    end
  end
end

function prompt_git -d "Display the current git state"
  set -l ref
  set -l dirty
  if command git rev-parse --is-inside-work-tree >/dev/null 2>&1
    set dirty (parse_git_dirty)
    set ref (command git symbolic-ref HEAD 2> /dev/null)
    if [ $status -gt 0 ]
      set -l branch (command git show-ref --head -s --abbrev |head -n1 2> /dev/null)
      set ref "➦ $branch "
    end
    set branch_symbol \uE0A0
    set -l branch (echo $ref | sed  "s-refs/heads/-$branch_symbol -")
    if [ "$dirty" != "" ]
      prompt_segment $color_git_dirty_bg $color_git_dirty_str "$branch $dirty"
    else
      prompt_segment $color_git_bg $color_git_str "$branch $dirty"
    end
  end
end

function fish_prompt
  # gets the error status of the last command and 
  # updates the @ symbol color with the indication
  if test "$status" -ne "0"
    set ARROW "$ERROR"
  else
    set ARROW "$SUCCESS"
  end

  # trim everything to the right of the . in whostname
  if test -n "$SHOW_HOST" 
    set HOST_STRING (echo $hostname | cut -f1 -d".")
    # add a space at the end
    set HOST_STRING "$HOST_STRING "
  end 

  # interactive user name @ (with error indicator) host name part with underline, date/time in YYYY-mm-dd format UTC, path info, and branch info (when available)
  echo (set_color $USER_COLOR)(whoami)(set_color $ARROW)@(set_color $HOST_COLOR)(echo $HOST_STRING)(set_color $DATE_COLOR)(date -u '+%Y-%m-%d %H:%M:%S') UTC (set_color $PATH_COLOR)(pretty_path)
  prompt_git
  echo "\$ "
end

function prompt_segment -d "Function to draw a segment"
  set -l bg
  set -l fg
  if [ -n "$argv[1]" ]
    set bg $argv[1]
  else
    set bg normal
  end
  if [ -n "$argv[2]" ]
    set fg $argv[2]
  else
    set fg normal
  end
  if [ "$current_bg" != 'NONE' -a "$argv[1]" != "$current_bg" ]
    set_color -b $bg
    set_color $current_bg
    echo -n "$segment_separator "
    set_color -b $bg
    set_color $fg
  else
    set_color -b $bg
    set_color $fg
    echo -n " "
  end
  set current_bg $argv[1]
  if [ -n "$argv[3]" ]
    echo -n -s $argv[3] " "
  end
end

function get_branch
  # minus symbol if there are no changes detected to tracked files
  # /dev/null prevents nonsensical errors when you are on directories not tracked by git.
  if test (git status --untracked-files=no --porcelain 2> /dev/null | wc -l) -eq 0
    set indicator "-"
  else
    set indicator "+"
  end
  
  set branch_name (git rev-parse --abbrev-ref HEAD 2> /dev/null)
  if test "$branch_name" != ""
    echo "[$indicator]$branch_name"
  else
    echo ""
  end
end

function ghb
  set URL (git remote get-url --push origin | sed 's/\.git$/\/tree\//g')(git rev-parse --abbrev-ref HEAD)
  echo "launching url $url..."
  if test (uname) = "Linux"
    xdg-open $URL
  else
    # This will definitely work on Darwin, somewhere else maybe?  xdg-open doesn't seem like the best default
    open $URL
  end
end

function fish_greeting
  set_theme_colors
  if test (uname) = "Darwin"
    neofetch --kitty ~/src/dotfiles/assets/apple.png --size 450px
  else if test "$SSH_TTY" = ""
    neofetch --kitty ~/src/dotfiles/assets/arch.png --size 450px
  else 
    neofetch 
  end
end

function cal
  if test "$argv" = ""
    /usr/bin/cal | lolcat
  else
    /usr/bin/cal $argv | lolcat
  end
end

function pretty_path
  # by default, Fish shell does not print ~ for $HOME
  echo (pwd | sed "s|^$HOME|~|g")
end

function set_theme_colors

#   set FG_COLOR    bd8141
#   set BG_COLOR    1e140a
#   set BRIGHT_RED  cb4b16
#   set CYAN        268bd2
#   set YELLOW      b58900
#   set ORANGE      FF9933

  if test "$FISH_THEME" = "gruvbox"
    set -gx ERROR      CC241D
    set -gx SUCCESS    98971A
    set -gx USER_COLOR C46210
    set -gx HOST_COLOR bfc225
    set -gx DATE_COLOR FF9933
    set -gx PATH_COLOR 268bd2
    set -gx GIT_COLOR  b58900
  else if test "$FISH_THEME" = "jellybeans"
    set -gx ERROR      CB0000
    set -gx SUCCESS    58A82F
    set -gx USER_COLOR 3399FF
    set -gx HOST_COLOR 00CC00
    set -gx DATE_COLOR FF9933
    set -gx PATH_COLOR 6B6FFF
    set -gx GIT_COLOR  03A9F4
  else
    set -gx ERROR      red
    set -gx SUCCESS    green
    set -gx USER_COLOR blue
    set -gx HOST_COLOR green
    set -gx DATE_COLOR yellow
    set -gx PATH_COLOR blue
    set -gx GIT_COLOR  cyan
  end
end

